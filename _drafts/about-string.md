---
layout: post
title: "그때는 맞고 지금은 틀리다 - StringBuilder보다 문자열 연결이 나을때"
categories: unity
comments: true
---
많은 분들이 아시듯이 C#의 string은 불변객체입니다. 한번 문자열이 지정되고 난 이후에는 변경이 불가능합니다. Replace()이나 += 연산자등은 문자열 내부의 값을 바꾸는 것이 아니라, 새로운 문자열을 생성한 후 반환하는 것입니다. 그래서 C#의 최적화에 관련된 글들을 보면, 문자열 결합이 필요한 경우 결합 연산자 사용을 지양하고, string.Format() 메서드로 포매팅한 문자열로 사용하거나 내부에 버퍼를 가진 StringBuilder 클래스를 사용하는 것을 권장하고 있습니다.

"그러니 문자열을 자주 연결할 일이 있으면 무조건 StringBuilder!"로 끝난다면 참 편하겠습니다만... 때로는 오히려 StringBuilder를 사용하는 것이 더 비효율적일 수 있습니다. 이번에는 제가 알아낸 범위 내에서, 문자열 결합에 가장 효율적인 방법을 적어보겠습니다.

## 리터럴 문자열을 결합하는 경우에는 그냥 + 연산자로 연결

리터럴 문자열만을 사용해서 문자열을 결합하는 경우에는 미리 최적화되어 결합된 상태로 반환됩니다. 아무런 코스트 없이 처리되므로 그냥 결합해서 쓰면 됩니다. "처음부터 연결된 문자열을 쓰지 리터럴끼리 결합할 일이 있나?"라고 생각하시는 분이 계실지도 모르겠는데(사실 저도 그랬습니다), 문자열이 너무 길어지거나 가독성을 위해서 적당한 부분에서 잘라서 쓰고 싶은 경우에 쓰면 되겠지요.

```C#
string literal1 = "리터럴 문자열끼리 결합하면 컴파일러가 자동으로 연결해줍니다." +
    " 문장이 너무 길거나 적당히 나눠서 가독성을 높이고 싶을때" +
    " 이런식으로 나누어서 쓰면 한층 보기 좋아집니다.";
string literel2 = "SELECT count(*)" +
    " FROM user" +
    " WHERE level > 5";
```

## 문자열 4개 이하를 연결하는 경우에는 + 연산자나 string.Concat() 사용

string 클래스의 \+ 연산자를 사용한다는 것은 string.Concat() 메서드를 사용하는 것과 같습니다. 유니티에서 프로파일러로 보면 컴파일러가 string.Concat()으로 바꾸어서 처리하고 있다는 것을 알 수 있습니다.

또한, string.Concat() 메서드의 오버로딩 목록을 보면 하나부터 4개의 문자열을 인수로 갖는 것이 있고, 그 이후로는 가변 개수로 받을 수 있게 되어있습니다. 이 string.Concat() 메서드는 미리 만들어진 인수 4개까지는 비관리 코드를 사용하여 빠르게 처리할 수 있도록 구현되어 있고, 그 이후로는 임시객체를 만들고 루프를 돌리는 등의 오버헤드가 발생합니다.

따라서, 리터럴이 아니더라도 문자열 4개까지는 그냥 + 연산자 혹은 string.Concat() 메서드를 사용하면 됩니다. 단, 이것은 어디까지나 \+ 연산자의 경우로, += 연산자를 사용하는 경우에는 그런 도움을 받을 수 없으니 유의하시기 바랍니다.

## StringBuilder

StringBuilder가 일반적인 string 결합보다 추천되는 이유는, 내부에 버퍼를 갖고 있으며 동적으로 크기가 변경되기에 매번 문자열을 추가할 때마다 메모리 할당이 일어나지 않기 때문입니다.

다만 이 설명은 절반만 맞고 절반은 맞지 않습니다. StringBuilder 역시 내부 버퍼의 크기를 넘는 문자열이 추가되면 더 큰 크기의 버퍼(보통 이전 버퍼 크기의 2배)를 할당하고, 기존 버퍼의 내용을 모두 복사하는 식으로 처리를 합니다.[^1] 즉, 경우에 따라서는 string 연결과 마찬가지로 문자열이 추가가 될때마다 재할당이 일어날 수 있습니다.

따라서 재할당이 일어나지 않도록 생성할 때 미리 충분한 크기의 영역을 확보해두어야 합니다. 예상되는 최종 출력 문자열의 크기를 미리 계산하여, 생성자에 넣어주거나 Capacity 속성을 통해 영역을 확보해 주는 습관을 들이는 것이 좋습니다.

[^1]: .NET 4.0 이후부터는 방식이 바뀌어서 새로운 StringBuilder를 만들고 연결 리스트로 연결하는 식으로 처리를 합니다. 따라서 기존의 버퍼가 버려지지 않는 대신, ToString() 메서드로 출력할때의 오버헤드는 더 커졌습니다.

- string
  - 리터럴 문자열 결합 시에는 미리 결합된 상태로 처리됨
  - 결합 연산자는 기본적으로 Concat()으로 변경됨
  - 문자열 4개까지는 한번에 Concat() 전부 결합되고, 그보다 많으면 루프를 돌면서 결합되게 됨
- string.Format()
  - 내부적으로 StringBuilder를 생성해서 사용
- StringBuilder
  - 내부에 string이 있고, 미리 할당된 크기 이상을 추가하는 경우 내부 string보다 큰 사이즈(보통 기존 string의 2배)의 영역을 할당 후 새로운 string을 생성한 후 복사
  - 루프에서 계속해서 Append 시 재할당이 일어나게 됨
  - 재할당이 일어나지 않도록 하려면 처음 생성시에 완성될 문자열의 크기를 어느 정도 예상하여 미리 할당해둬야 함. 그러지 않으면 그냥 string 결합하는 것과 차이가 없음(O(N)과 O(LogN)의 차이는 있겠지만)
  - StringBuilder.AppendFormat()은 내부적으로 string.Format()을 사용 후 붙이는 형태. 즉 StringBuilder 내에서 새로운 StringBuilder 객체가 새로 생성되게 됨
- 결론
  - 리터럴 문자열 뿐이라면 그냥 결합 연산자 사용.
  - 4개까지라면 결합 연산자 혹은 Concat() 사용
  - 그 이상은 StringBuilder 사용. 단, 미리 할당크기를 정해둘 것.
